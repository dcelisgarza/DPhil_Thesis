\chapter{Future work}
\label{c:future}

It is clear that there are some fundamental problems preventing us from exploiting the capabilities of discrete dislocation dynamics. The code DDLab, the code that EasyDD is based on made some decisions that would ultimately limit its potential. Namely, the lack of attention paid to the cost of dynamic memory allocation, procedural nature of the code, and its choice of programming language. These choices were reasonable upon inception, but as the Tarleton group has increased in size and maturity it has become evident that it is not enough. We are reaching the upper limits of what can be done with \mintinline{matlab}{MATLAB}. There are more things we can do, more things we are doing. But a constant obstacle in obtaining results is how long they take to get and how difficult it is to add new functionality, even changing boundary conditions.

The work described in \cref{c:easydd,c:topology,c:tractions} has done much in not only producing more accurate simulations, but doing so faster. Fengxian Liu's work on modelling climb, diffusion and inclusions would greatly benefit from better designed code. Haiyang Yu's work on modelling hydrogen \cite{YU2018} and nanoindentation would also stand to benefit a great deal from a parallelised and faster dislocation separation algorithm. Potential work relevant to modelling dislocation dynamics in nuclear reactors such as post-damage cascade dislocation dynamics \cite{sand2014radiation}, necessitates spontaneous generation of dislocations as a network evolves. Including stochasticity in the form of Langevin dynamics \cite{li2019diffusion} is also highly relevant, especially at higher temperatures.

Many of these require a complete overhaul to some of the most fundamental parts of EasyDD. Even so it would be hindered by the fact that \mintinline{matlab}{MATLAB} is a scripting language, not designed to be a scientific computing one. It lacks many modern features that make life easy when dealing with large codebases. Furthermore, the need for licences can represent a prohibitative barrier for users and researchers. Not only this, but the cost of distributed licences that allow \mintinline{matlab}{MATLAB} to run on clusters severely limits scalability and potential for collaboration.

But there is a better way. Prompted by the public release of the Imperial College COVID-19 source code \href{https://github.com/mrc-ide/covid-sim}{\texttt{https://github.com/mrc-ide/covid-sim}}, and the recurring issues with computational efficiency, compiler compatibility and availability, and fundamental technical debt inherited from \texttt{DDLab} \cite{ddlab}. We started a weekend project that has turned out to be \emph{extremely} promising.

The language of choice is \mintinline{julia}{Julia} \cite{julia}. An open-source JIT (just in time) compiled language designed for scientific computing. It has many features that make it an excellent candidate for a new generation of open, scientific software.
\begin{enumerate}
    \item Multiple dispatch: methods are dispatched and compiled based on the types of all their arguments, the types propagate their way through child functions, creating optimal code without having to worry about data types.
    \item Type system: its type system is based on set theory, where types are arranged in a genealogical tree with broader types giving way to narrower ones, e.g. \mintinline{julia}{Float64 <: AbstractFloat <: Real <: Number <: Any == true}. Structures can be parametric on type. These features let developers create generic code without bothering with type annotations. This type of code greatly improves modularity and allows for ``magic'' like automatic differnetiation without the programme knowing the rules of calculus.
    \item CPU and GPU Parallelisation: parallelising loops is trivial.
    \item Metaprogramming: lets code write code. This can be used to autoparallelise functions without rewriting. It also lets developers define custom syntax and precompute values like an extremely powerful C-preprocessor.
    \item Modern features: \mintinline{julia}{Julia} has all the features of a modern programming language. From a booming and quickly growing package ecosystem already with a few best in class libraries; an integrated testing system and documentation generation; extremely powerful code introspection tools; to interctivity.
\end{enumerate}

The code can be found here \href{https://github.com/dcelisgarza/DDD.jl}{\texttt{https://github.com/dcelisgarza/DDD.jl}}. As it has been a didactic side project, it is nowhere near feature complete. But so far, comparisons with C-accelerated portions of EasyDD peg it at around 10\% faster. Direct comparisons to pure \mintinline{matlab}{MATLAB} show between $5$ to $>1000 \times$ faster depending on the function. It is the result of the lessons learned while working on EasyDD. Its design avoids the same pitfalls and has a clear vision for usability, modularity, and extensibility, without sacrificing performance. We think it to be a more than worthwhile endeavour to bite the bullet now rather than wait until there is no more juice to squeeze out of \mintinline{matlab}{MATLAB}. We are looking to continue this as a research software engineering project. Not only so that the shackles of proprietary software can be broken; but also so the full, ambitious vision of EasyDD can be realised.

% 773 words
