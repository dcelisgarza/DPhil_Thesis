\chapter{Future work}
\label{c:future}

\section{EasyDD}

EasyDD is an actively developed research code. Much remains to be done, here we describe some of the more immediate concerns.

\subsection{Modularisation}

There are still functions with numerous parameters. They can be simplified by adding variables that fall within certain categories into structures. Daniel Hortelano-Roig has been doing a lot of work in this regard on a branch in his fork of EasyDD. Some has been backported to the current version of EasyDD, namely the surface node sets, which were used in \cref{c:simulations} to set the boundary conditions.

\subsection{New capabilities}

Haiyang Yu, Fenxian Liu and Daniel Hortelano-Roig have been working on the effects of hydrogen and nanoindentation, inclusions and diffusion, and HCP simulations respectively. Their work has not yet been integrated into EasyDD. There has to be a coordinated effort, using generic functions and modulirisation to seamlessly integrate these new features into the main branch.

\subsection{Fixes}

The fix to the surface remeshing described in \cref{s:surfRem}, may not be ideal. It could perhaps be improved by creating a new node label such that those nodes are not accounted for in the slip step calculation and not be projected to pseudo-infinity by the surface remeshing. This would require modifying the surface remeshing and displacement calculation to exclude these from such processes; as well as modifying the Peach-K\"{o}hler and self-forces to exclude them from those calculations, but allowing them to participate in the remote force calculation as they would be in the ``bulk''.

\subsection{Performance improvements}

The remote force calculation was broken by an incompatibility between a new version of \mintinline{matlab}{MATLAB} and \mintinline{CUDA}{CUDA}. This was fixed during this project, but it uses a very suboptimal memory access pattern, it only has a cache hit rate of $1/9$. As a result, it takes about an order of magnitude more dislocations than the parallelised tractions to break even with the serial version on our current hardware. Changing the memory access pattern would increase the GPU memory used by $2\times$, but would allow the GPU to access the memory $9\times$ more efficiently than the current implementation. Since as we cannot remotely approach the memory capacity of our current GPU with our current capabilities, the increased memory footprint is a price we can afford in the name of increased performance. It could bring it more in line to the performance of the numeric tractions.

\subsection{Conclusions}

EasyDD is an actively developed research code. Its functionality is ever expanding, but in a manner like urban sprawl, unplanned and chaotic. The result is a fractured codebase with at least as many diverging branches as contributors. Unfortunately, many of these are not mutually compatible. This has been an obstacle for the Tarleton Group, but EasyDD is now garnering outside eyes. It's therefore imperative that future and past members make an effort to unify their works. It's also extremely important that any additions and improvements make use of standards, guidelines, and techniques such as those described in \cref{s:rse}. This way, the maintainability and usability of EasyDD will improve rather than decay as more people contribute to its features.
\savearabiccounter
% 500 words
