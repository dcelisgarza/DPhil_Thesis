{"rule":"OXFORD_SPELLING_NOUNS","sentence":"^\\QA civilisation's ability to gain mastery of the properties and usage of materials is often strongly correlated with its success in history \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"OXFORD_SPELLING_NOUNS","sentence":"^\\QWhen a civilisation learned to harness the properties of a novel material, its influence often grew as a result \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"OXFORD_SPELLING_ISE_VERBS","sentence":"^\\QA constant feature of nuclear energy production is the exposure of reactor materials to large loads of ionising and non-ionising radiation.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QLocation Radiation Type MCF (ITER) ICF (LMJ) 1st Wall Neutron flux 3e18 m^-2.s^-1 1.5e25 m^-2.s^-1 Neutron fluence* 3e25 m^-2 3e18 m^-2 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-ray dose rate 2e3 .s^-1 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q 1e10 .s^-1 Energetic ion/atom flux 5e19 m^-2.s^1 1st Diagnostic Neutron flux 1e17 m^-2.s^-1 1e26 m^-2.s^-1 Neutron damage rate 6e-9 dpa.s^-1 negligible Neutron fluence* 2e24 m^-2 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qe19 m^-2 Neutron damage 1e-1 dpa negligible \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-ray dose rate \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qe2 .s^-1 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qe10 .s^-1 Energetic ion/atom flux \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qe18 m^-2 Nuclear heating 1 .m^-3 0 Operating temperature 520 293 Atmosphere Vacuum Air Other EM pulse [range-units = single]10 500 .m^-1 @ 1 Shrapnel [range-units = single]1 10 .s^-1 @ \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q [Estimated operating conditions of MCF and ICF fusion reactors.]\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QEstimated operating environment comparison between MCF (ITER) and ICF (LMJ).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qb X-ray image of the actual capsule for N130927 with DT fuel layer and surrounding CH (carbon–hydrogen) plastic ablator.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qc X-ray radiation drive temperature as a function of time for the National Ignition Campaign (NIC) low-foot implosion and the post-NIC high-foot implosion.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe two other dissipation mechanisms are: short-circuit, sc, which depends on frequency and occurs when a direct path from transistor to ground is made as a result of multiple transistors conducting simultaneously; and leakage, leak, which depends on the voltage and is due to micro-currents between doped parts a transistor.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QEnergy required by a Samsung Galaxy S2 CPU at 37 to complete the Gold-Rader implementation of the bit-reverse algorithm.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QEnergy required by a Samsung Galaxy S2 CPU at 37 to complete the Gold-Rader implementation of the bit-reverse algorithm.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QArrows represent fetch requests by single threads in a GPU.\\E$"}
{"rule":"NEEDS_FIXED","sentence":"^\\QEfficient parallelisation of many problems requires coalesced memory access as shown in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, which means we have to be extremely careful when mapping CPU memory to global GPU (device) memory.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qif (y == 0) x = a+b; else if (y == 1) x = a*b; else x = a/b; CPU code will only execute if the condition is met.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qp = (y == 0); p: x = a+b;\\E$"}
{"rule":"MULTIPLICATION_SIGN","sentence":"^\\Qp = (y == 1); p: x = a*b;\\E$"}
{"rule":"MULTIPLICATION_SIGN","sentence":"^\\Qif (y == 0) x = a+b; else if (y == 1) x = a*b; else x = a/b; CPU code will only execute if the condition is met.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QThere are at present two methods with which to do so, the sss:superposition and the sss:discrete_continuum.\\E$"}
{"rule":"CD_NN","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the 4th-order elasticity tensor, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q the small strain tensor, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are the body forces and, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q:, is the double dot product defined as, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, for a rank 4 tensor \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, and rank 2 tensor \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"CD_NN","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is the 4th-order elasticity tensor, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q the small strain tensor, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are the body forces and, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q:, is the double dot product defined as, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, between a rank 4 tensor (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) and a rank 2 tensor (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\Qa_non-singular_continuum_theory_of_dislocations took it upon themselves to define and justify a different Burgers vector distribution that maintains the mathematical convenience of the classical formulation that also eliminates such an unphysical assumption.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qa_non-singular_continuum_theory_of_dislocations took it upon themselves to define and justify a different Burgers vector distribution that maintains the mathematical convenience of the classical formulation that also eliminates such an unphysical assumption.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAside from the Hall-Petch effect, the model has also been utilised by \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to study the thickness effects of three different types of polycrystalline thin films: no surface treatment, surface passivation layer, and surface grain refinement zones .\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qtwinning modelled four scenarios in order to deconvolute the effects that twins and grain boundaries have on the mechanical behaviour of a cubic crystal.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qtwinning modelled four scenarios in order to deconvolute the effects that twins and grain boundaries have on the mechanical behaviour of a cubic crystal.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsm_incl not only modelled a cuboid inclusion, but bimetallic interfaces in 3D.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qgpu_ddd investigated some of the more computationally intensive parts of DDD in DDLab \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, a freely available DD code for Matlab.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qgpu_ddd realised that the segment-segment interaction calculation can be done via \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q parallelism, where single pairs of dislocation segments are sent to a single thread, and then globally reduced.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QIf anything should be clear from the present work, is that materials science is far from being solved.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qtwinning modelled four scenarios in order to deconvolve the effects that twins and grain boundaries have on the mechanical behaviour of a cube-shaped crystal.\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\QMaterials challenges in nuclear energy\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QIf anything should be clear from the present work, is that materials science is far from solved.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QDislocation Based Modelling of Fusion Relevant Materials ox_brand_cmyk_pos.eps hmc.eps Daniel Celis Garza University of Oxford Harris-Manchester Materials Edmund Tarleton Angus Wilkinson Doctor in Philosophy Hilary Term 2021\\E$"}
{"rule":"PUNCTUATION_PARAGRAPH_END","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QFortunately, matlab MATLAB does not truly have object-oriented capabilities, so it forces either a procedural or data-driven approach.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmatlab MATLAB has an old method of doing so using matlab feval(), where the first argument is the name of the file whose function is being called, and subsequent arguments are passed on to the function.\\E$"}
{"rule":"EACH_OTHERS","sentence":"^\\QIf experts within the same research group find it difficult to incorporate each others' additions to our work, there is little hope for the general user.\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE_2","sentence":"^\\QThe introduction of regressions makes it so code must be thoroughly and exhaustively tested before merging two people's work.\\E$"}
{"rule":"WHETHER","sentence":"^\\QAnd since it is generic, we can choose whether or not to use it by changing an input file rather than messing with the source code.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QTiming the equivalent of allocating a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q mesh in matlab MATLAB 2020b takes on the order of 70 (for x86 CPU architectures), which is in-line to what it costs in C C. Deallocating memory takes about \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q longer.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QIn a function that otherwise takes a few , adding another 400 of spurious allocation is a significant overhead that can be easily remedied.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QHowever, matlab MATLAB has a special form of it that exploits sparsity.\\E$"}
{"rule":"EN_GB_SIMPLE_REPLACE","sentence":"^\\QIt is not only the cost of allocating, but also the cost of garbage collection (GC) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q i.e. automatically freeing memory based on a set of criteria can be significantly higher.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmatlab MATLAB is infamous for the way it will happily dynamically grow an array when going out of bounds.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis is now done automatically on a need-to-compile basis and has a fallback in case no CUDA CUDA compiler is found.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QDocumentation is written as Markdown docstrings within the source and the standard library documentation package will automatically generate the documentation, which can be hooked up to a remote testing service and hosted as a HTML page on your git webhosting service of choice.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QSome refactoring of common code should put it at \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q lines, which is about the same number of lines in the remote force calculation written in c C.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QWe are reaching the upper limits of what can be done with matlab MATLAB.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThe most promising for scientific computing is widely regarded to be julia Julia \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QEven so, its potential would be hindered by the fact that matlab MATLAB is a scripting language not designed for scientific computing.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QNot only this, but the cost of distributed licences that allow matlab MATLAB to run on clusters severely limits scalability and potential for collaboration—something that at one point, inhibited this project.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QAlthough as of v1.6, it might be more appropriate to say call julia Julia a JAOT (Just Ahead Of Time) compiled language thanks to its massively improved precompilation capabilities.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QMetaprogramming: one of the most powerful and esoteric features of julia Julia.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QMuch like lisp Lisp, code is an object that can be manipulated by the language itself.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QModern features: julia Julia has all the features of a modern programming language.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QInteroperability: calling other languages from julia Julia is seamless, so the use of external libraries or languages is as easy as calling a julia Julia function.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QHowever, julia Julia is so powerful and performant that most of its packages are mono-language.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QA feature often shared by other modern languages such as go Go, rust Rust, swift Swift and elixir Elixir.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis works like matlab MATLAB's built-in matlab save() and matlab load() functions.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThis is another great option that is in-built to the language, but is also julia Julia-specific and successfully reading files is only guaranteed if they were generated with the same version of julia Julia being used.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjava JSON is an open standard for representing objects as dictionaries in a file.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QIn some cases the loaded data has to be used to manually create the structures, but if julia JLD2 is used, it works like matlab MATLAB's matlab save() and matlab load().\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QJLD2 is advantageous because it saves structure information so loaded variables will be of the correct type, however it is specific to julia Julia and is still under active development.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q# Dislocation parameters dlnParams = DislocationParameters(; mobility = mobBCC(), dragCoeffs = (edge = 1, screw = 1e-1, climb = 1e9, line = 1e-5), coreRad = 0.015 * sqrt(2), minSegLen = 0.15 * sqrt(2), maxSegLen = 1.5 * sqrt(2), coreEnergy = 1 / (4 * π) * log(0.015 * sqrt(2) / 3.5e-5), coreRadMag = 3.5e-4 ) # Material parameters matParams = MaterialParameters(; crystalStruct = BCC(), μ = 1, μMag = 80e3, ν = 0.25 ) # FEM parameters for a regular cuboid mesh with linear elements # with the purpose of modelling a cantilever loading experiment femParamsC = FEMParameters(; type = DispatchRegularCuboidMesh(), order = LinearElement(), model = CantileverLoad(), dx = 23.0, # Length in x dy = 17.0, # Length in y dz = 13.0, # Length in z mx = 7, # Elements in x my = 5, # Elements in y mz = 3 # Elements in z ) # Slip system information for two BCC slip systems slipSystems = SlipSystem(; crystalStruct = BCC(), slipPlane = Float64[-1 1; 1 -1; 0 0], bVec = Float64[1 1; 1 1; 1 -1] ) # Integration parameters intParams = IntegrationParameters(; method = AdaptiveEulerTrapezoid(), abstol = dlnParams.collisionDist / 2, reltol = dlnParams.collisionDist / 2 ) # Integration time variables intTime = IntegrationTime(; dt = 0.0, time = 0.0); All together, these represent about 60 constants that control all aspects of a simulation.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia Julia is a fully compiled language, where files can be run from a terminal like any other compiled language.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QWe represent interactive REPL (Read Eval Print Loop, i.e. julia Julia's “terminal”), use by omitting line numbers.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QHowever, julia Julia is so powerful and performant that most of its packages are single-language.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QRegardless, julia Julia uses Markdown natively, so it produces documentation and answers such queries in Markdown-formatted text.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\QmeshC = buildMesh(matParams, femParamsC) plotFEDomain(meshC; camera = (10, -2)) The mesh is built using the canonical numbering system defined in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, and builds the node sets accordingly (shown in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia> d = (a = 1, b = 2 + im, c = false) (a = 1, b = 2.0 + 1.0im, false) julia> d[1] 1 julia> d[b] 2.0 + 1.0im julia> d.c false They act like on-the fly structures and are very convenient when making composable and generic code.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia Julia has a parametric type are called, julia NamedTuple.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia> keys(meshC.surfNode) (:x0y0z0, :x1y0z0, :x1y1z0, :x0y1z0, :x0y0z1, :x1y0z1, :x1y1z1, :x0y1z1, :x_y0z0, :y_x1z0, :x_y1z0, :y_x0z0, :x_y0z1, :y_x1z1, :x_y1z1, :y_x0z1, :z_x0y0, :z_x1y0, :z_x1y1, :z_x0y1, :xz_y0, :yz_x1, :xz_y1, :yz_x0, :xy_z0, :xy_z1) The keys say exactly what they represent, and are canonically ordered \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia NamedTuples are also used in the FE mesh data structure, where they represent surface node sets.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q# Pillar loading femParamsP = FEMParameters(; type = DispatchRegularCuboidMesh(), order = LinearElement(), model = PillarLoad(), dx = 17.0, dy = 13.0, dz = 23.0, mx = 5, my = 3, mz = 7, ) meshP = buildMesh(matParams, femParamsP); boundaryP, forceDispP = Boundaries(femParamsP, meshP); DDD.jl canonical pillar loading boundary node sets.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qdx, dy, dz = femParamsC.dx, femParamsC.dy, femParamsC.dz segLen = (dlnParams.minSegLen + dlnParams.maxSegLen) / 2\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QprismOct = DislocationLoop(; loopType = loopPrism(), # Prismatic loop numSides = 8, # 8 sides nodeSide = 1, # 1 node per side (corners) numLoops = 5, # Will generate 5 loops in the network segLen = segLen * ones(8), # Each side is of equal length slipSystemIdx = 1, # Slipsystem 1 slipSystem = slipSystems, # Available slip systems label = nodeTypeDln.(ones(Int, 8)), # Node type buffer = 0, # Spacing for the distribution, may change in the future range = [0 dx; 0 dy; 0 dz], # Range on which to distribute dist = Rand(), # Random uniform distribution in space ) shearPent = DislocationLoop(; loopType = loopShear(), # Shear loop numSides = 5, nodeSide = 2, # Two nodes per side (corners and mid-segment) numLoops = 5, segLen = segLen * ones(10), # 10 segments per loop this time slipSystemIdx = 2, slipSystem = slipSystems, label = nodeTypeDln.(ones(Int, 10)), buffer = 0, range = [0 dx; 0 dy; 0 dz], dist = Rand(), ) When the loops are generated, only one of each is made, and they are centred about the origin (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia>?nodeTypeDln search: nodeTypeDln nodeTypeFE\\E$"}
{"rule":"PUNCTUATION_PARAGRAPH_END","sentence":"^\\Qjulia>?nodeTypeDln search: nodeTypeDln nodeTypeFE\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qnetwork = DislocationNetwork((prismOct, shearPent)) # Plot network pre-remeshing.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Q# Compute total force on segments = # Peach-Koehler force (zero because there is no \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) # + Self force # + Remote force calcSegForce!(dlnParams, matParams, meshC, forceDispC, network) # Compute nodal mobilities dlnMobility!(dlnParams, matParams, network) # Remesh the surface network = remeshSurfaceNetwork!(meshC, boundaryC, network) # Coarsen the internal network network = coarsenNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Refine the internal network network = refineNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Plot remeshed network remFEFig = plotNodes( meshC, network, m = 2, l = 3, linecolor = :blue, markershape = :circle, markercolor = :blue, legend = false, camera = (-15, 25) ) # Find all surface nodes (both mobile and fixed) idx = findall(x -> x ∈ (3, 4), network.label) # Plot surface nodes on the same figure as red circles.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q# Compute total force on segments = # Peach-Koehler force (zero because there is no \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) # + Self force # + Remote force calcSegForce!(dlnParams, matParams, meshC, forceDispC, network) # Compute nodal mobilities dlnMobility!(dlnParams, matParams, network) # Remesh the surface network = remeshSurfaceNetwork!(meshC, boundaryC, network) # Coarsen the internal network network = coarsenNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Refine the internal network network = refineNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Plot remeshed network remFEFig = plotNodes( meshC, network, m = 2, l = 3, linecolor = :blue, markershape = :circle, markercolor = :blue, legend = false, camera = (-15, 25) ) # Find all surface nodes (both mobile and fixed) idx = findall(x -> x ∈ (3, 4), network.label) # Plot surface nodes on the same figure as red circles.\\E$"}
{"rule":"ARROWS","sentence":"^\\Q# Compute total force on segments = # Peach-Koehler force (zero because there is no \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) # + Self force # + Remote force calcSegForce!(dlnParams, matParams, meshC, forceDispC, network) # Compute nodal mobilities dlnMobility!(dlnParams, matParams, network) # Remesh the surface network = remeshSurfaceNetwork!(meshC, boundaryC, network) # Coarsen the internal network network = coarsenNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Refine the internal network network = refineNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Plot remeshed network remFEFig = plotNodes( meshC, network, m = 2, l = 3, linecolor = :blue, markershape = :circle, markercolor = :blue, legend = false, camera = (-15, 25) ) # Find all surface nodes (both mobile and fixed) idx = findall(x -> x ∈ (3, 4), network.label) # Plot surface nodes on the same figure as red circles.\\E$"}
{"rule":"LC_AFTER_PERIOD","sentence":"^\\Q# Compute total force on segments = # Peach-Koehler force (zero because there is no \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) # + Self force # + Remote force calcSegForce!(dlnParams, matParams, meshC, forceDispC, network) # Compute nodal mobilities dlnMobility!(dlnParams, matParams, network) # Remesh the surface network = remeshSurfaceNetwork!(meshC, boundaryC, network) # Coarsen the internal network network = coarsenNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Refine the internal network network = refineNetwork!(dlnParams, matParams, meshC, forceDispC, network) # Plot remeshed network remFEFig = plotNodes( meshC, network, m = 2, l = 3, linecolor = :blue, markershape = :circle, markercolor = :blue, legend = false, camera = (-15, 25) ) # Find all surface nodes (both mobile and fixed) idx = findall(x -> x ∈ (3, 4), network.label) # Plot surface nodes on the same figure as red circles.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qscatter!(network.coord[1, idx], network.coord[2, idx], network.coord[3, idx], m = 2, markercolor = :red) Pre remeshed network.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcalc_uTilde!(forceDispC, meshC, boundaryC, matParams, network) # Copy structure to another variable.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qjulia Julia was built as a language for scientific computing.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThe self-forces and Peach-Köhler forces as a result of the dislocations being inside a cuboid mesh are both \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q faster than their matlab MATLAB counterparts.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QDDD.jl's mesh refinement uses a better heuristic than dynamically sizing arrays every time a new node is added to the network, so it is about as slow as matlab MATLAB's when it needs to allocate memory.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QCollision detection has not yet been compared to its EasyDD counterpart (which is written in c C), and neither have the untested procedures.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QCare has been taken to do things as optimally as possible, and julia Julia's typesystem lets sparse arrays be treated in exactly the same way as dense ones, which is not always the case in matlab MATLAB, which has thwarted efforts at sparsifying various arrays that would benefit from it.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QnetworkFEFig = plotNodes( meshC, network, m = 2, l = 3, linecolor = :blue, markershape = :circle, markercolor = :blue, legend = false, camera = camera = (-15, 25) )\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThe calculation of field point stresses for numeric tractions is %\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q faster than its c C counterpart.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThe \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q remote force computation is 10% faster than its equivalent c C function.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QIt is also CPU-parallelised in DDD.jl, which was almost trivial to do, which is definitely not the case for c C. For large numbers of dislocations (1000+ segments) it offers linear scaling with number of threads.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QIt should come as no surprise that DDD.jl is substantially faster than the matlab MATLAB portions of EasyDD.\\E$"}
{"rule":"PUNCTUATION_PARAGRAPH_END","sentence":"^\\QThe corrective field which accounts for both the applied and image stress is obtained numerically by solving the elastic boundary value problem, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Once the solutions to both problems are known, their superposition solves the desired mixed boundary value problem, \\E(?:Dummy|Ina|Jimmy-)[0-9]+$"}
{"rule":"CD_NN","sentence":"^\\Q[FE nodes are shared between surface elements.]FE nodes are shared by either 4 element faces or 3 if it is a corner node.\\E$"}
{"rule":"AGREEMENT_SENT_START","sentence":"^\\QThe Burgers vectors for the different scenarios are \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, as defined in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q; and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, as defined in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"NEEDS_FIXED","sentence":"^\\QRequires minted, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and its dependencies to compile.\\E$"}
{"rule":"PUNCTUATION_PARAGRAPH_END","sentence":"^\\QParameter Value Crystal Structure BCC \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Grid Size \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Domain Size \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Lattice size \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Qm \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Min segment length \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q Max segment length \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+$"}
{"rule":"HAVE_PART_AGREEMENT","sentence":"^\\QCPUs and GPUs have cache heirarchies designed to progressively get smaller and faster the closer they are to the processor.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QFor the simulations presented in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, the GPU gives an \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q–\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q speed-up (only for the traction calculation, not the whole simulation)—this is for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q thousand dislocation segments, fewer than those and the gains aren't very significant.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QIt was almost trivial to implement, which is definitely not the case for c C. For large numbers of dislocation segments (\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) it offers linear scaling with number of threads on an AMD Ryzen 7 1700 3.0 .\\E$"}
{"rule":"PUNCTUATION_PARAGRAPH_END","sentence":"^\\QLoading direction Slip plane Burgers vector \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q \\E(?:Dummy|Ina|Jimmy-)[0-9]+$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qa_non-singular_continuum_theory_of_dislocations defined and justified a different Burgers vector distribution that maintains the mathematical convenience of the classical formulation and eliminates such an unphysical assumption.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qgpu_ddd realised that the segment-segment computation can be done via \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q parallelism, where single pairs of dislocation segments are sent to a single thread, and then globally reduced.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmatlab MATLAB has an old method that enables generic programming using matlab feval(), where the first argument is the name of the file whose function is being called, and subsequent arguments are passed on to the function.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmatlab MATLAB is infamous for the way it will happily grow an array dynamically when going out of bounds.\\E$"}
{"rule":"EN_GB_SIMPLE_REPLACE","sentence":"^\\QMore memory allocation also means more garbage collection (GC) \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q i.e. automatically freeing memory, based on a set of criteria.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QIn a function that otherwise takes a few , adding almost 0.5 because of spurious allocation is an overhead that can be very easily remedied.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QRecuerdo que lloraste en el teléfono, se te cerró la garganta y a mí también.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QAsí que le hablaste a abuelita Raquel mientras le hablé a papá.\\E$"}
{"rule":"EN_SPECIFIC_CASE","sentence":"^\\QSin tí, el mundo sería un lugar más cruel y pobre, no merece un ángel tan grande y puro como tú.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QComo siempre, no platicamos mucho, pero esa vez porque le querías decir a abuelita Teté y a mis tíos, y yo le quería avisar a David.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QEscribo esta dedicatoria antes de acabar porque lo prometido es deuda y esta madre la voy a acabar.\\E$"}
{"rule":"WRONG_PRP_AT_SENT_START","sentence":"^\\QMe has hecho falta, te extraño mucho.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QMe hicieron reír cuando solo sabía llorar.\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE","sentence":"^\\QThank you for having me over for Christmas so I wouldn't be alone, it meant the world to me.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\Q“La Isla”, mis amigos mi Ohana elegida desde mi retorno a México en el 2008.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QSimulation strain rates are also necessarily higher than experimental ones as discrete dislocation dynamics time scales are on the order of .\\E$"}
